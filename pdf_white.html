<!doctype html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <title>PDF 灰底變白（離線）</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Arial; padding:18px; max-width:900px; margin:0 auto; }
    h1 { font-size:20px; margin-bottom:6px; }
    .controls { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
    input[type=file] { padding:6px; }
    #log { white-space:pre-wrap; background:#f6f6f6; padding:10px; border-radius:6px; max-height:220px; overflow:auto; margin-top:12px; font-size:13px; }
    #progress { width:100%; height:8px; background:#eee; border-radius:6px; overflow:hidden; margin-top:8px; }
    #progress > div { height:100%; background:#2b8cff; width:0%; transition:width .2s; }
    label.range { display:flex; gap:8px; align-items:center; }
    button { padding:8px 12px; border-radius:6px; border:1px solid #ccc; background:white; cursor:pointer; }
  </style>
</head>
<body>
  <h1>PDF 灰底轉白（離線）</h1>
  <p>上傳 PDF → 調整 threshold（灰色淺過此值會變白）→ 開始處理 → 下載新 PDF。檔案會被 rasterize（影像化）。較大檔案或大量頁數會花時間及用更多記憶體。</p>

  <div class="controls">
    <input id="file" type="file" accept="application/pdf" />
    <label class="range">Threshold: <input id="th" type="range" min="150" max="255" value="200" /> <span id="thval">200</span></label>
    <button id="start" disabled>開始處理</button>
    <button id="cancel" disabled>取消</button>
    <button id="download" disabled>下載新 PDF</button>
  </div>

  <div id="progress"><div></div></div>
  <div id="log">未開始。</div>

  <!-- PDF.js CDN -->
  <script src="https://unpkg.com/pdfjs-dist@3.6.172/build/pdf.min.js"></script>
  <!-- jsPDF CDN -->
  <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script>
  (function(){
    const fileInput = document.getElementById('file');
    const startBtn = document.getElementById('start');
    const cancelBtn = document.getElementById('cancel');
    const downloadBtn = document.getElementById('download');
    const logEl = document.getElementById('log');
    const progBar = document.querySelector('#progress > div');
    const thRange = document.getElementById('th');
    const thVal = document.getElementById('thval');

    let cancelRequested = false;
    let outputPdfBlob = null;

    thRange.addEventListener('input', ()=> thVal.textContent = thRange.value);

    fileInput.addEventListener('change', ()=>{
      startBtn.disabled = !fileInput.files.length;
    });

    cancelBtn.addEventListener('click', ()=> {
      cancelRequested = true;
      log('取消請求中...');
    });

    downloadBtn.addEventListener('click', ()=>{
      if (!outputPdfBlob) return;
      const url = URL.createObjectURL(outputPdfBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'converted_white_bg.pdf';
      a.click();
      URL.revokeObjectURL(url);
    });

    startBtn.addEventListener('click', async ()=>{
      if (!fileInput.files.length) return;
      startBtn.disabled = true;
      cancelBtn.disabled = false;
      downloadBtn.disabled = true;
      cancelRequested = false;
      outputPdfBlob = null;
      progBar.style.width = '0%';
      log('讀取檔案...');
      const file = fileInput.files[0];

      try {
        const arrayBuffer = await file.arrayBuffer();

        // init PDF.js
        const pdfjsLib = window['pdfjs-dist/build/pdf'];
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.6.172/build/pdf.worker.min.js';
        const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
        const pdf = await loadingTask.promise;
        const pageCount = pdf.numPages;
        log(`文件載入：${pageCount} 頁`);
        
        // jsPDF setup (units px so we can use canvas pixel sizes)
        const { jsPDF } = window.jspdf;
        const outDoc = new jsPDF({ unit: 'px', format: [1,1] }); // temporary

        // We'll remove initial blank page created by jsPDF
        outDoc.deletePage(1);

        for (let i=1;i<=pageCount;i++){
          if (cancelRequested) { log('已取消'); break; }
          log(`處理第 ${i} / ${pageCount} 頁...`);
          progBar.style.width = `${Math.round((i-1)/pageCount*100)}%`;

          const page = await pdf.getPage(i);
          const viewport = page.getViewport({ scale: 2.0 }); // scale 可調，越大越清晰但越重
          const canvas = document.createElement('canvas');
          canvas.width = Math.round(viewport.width);
          canvas.height = Math.round(viewport.height);
          const ctx = canvas.getContext('2d');

          // render page to canvas
          await page.render({ canvasContext: ctx, viewport: viewport }).promise;

          // process pixels: lighten / make near-white areas pure white
          const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
          const data = imgData.data;
          const threshold = parseInt(thRange.value,10);
          // We'll use perceived luminance to decide
          for (let p=0; p<data.length; p+=4){
            const r = data[p], g = data[p+1], b = data[p+2];
            // perceived luminance
            const lum = 0.299*r + 0.587*g + 0.114*b;
            // if luminance is above threshold, set to white
            if (lum >= threshold) {
              data[p] = 255; data[p+1] = 255; data[p+2] = 255;
            }
            // optional: you could also boost contrast or desaturate shadows if needed
          }
          ctx.putImageData(imgData,0,0);

          // convert canvas to dataURL (JPEG for smaller size)
          // quality 0.92 default
          const dataUrl = canvas.toDataURL('image/jpeg', 0.92);

          // add page to jsPDF with same pixel dimensions
          outDoc.addPage([canvas.width, canvas.height], 'portrait');
          outDoc.setPage(outDoc.getNumberOfPages());
          outDoc.addImage(dataUrl, 'JPEG', 0, 0, canvas.width, canvas.height);

          // free memory
          page.cleanup && page.cleanup();
        }

        if (!cancelRequested) {
          progBar.style.width = '100%';
          log('匯出 PDF 中...');
          const pdfBlob = outDoc.output('blob');
          outputPdfBlob = pdfBlob;
          downloadBtn.disabled = false;
          log('處理完成，可按「下載新 PDF」。');
        } else {
          log('程序被取消，無檔案輸出。');
        }

      } catch (err) {
        console.error(err);
        log('錯誤：' + (err && err.message ? err.message : String(err)));
      } finally {
        startBtn.disabled = false;
        cancelBtn.disabled = true;
      }
    });

    function log(text){
      logEl.textContent = text + '\n' + logEl.textContent;
    }

  })();
  </script>
</body>
</html>
